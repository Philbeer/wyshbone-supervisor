You are editing the Wyshbone Supervisor repl.

========================================
GOAL (SUP-001 — Lead generation plan object)
========================================
Create:

1) A **LeadGenPlan representation** (TypeScript types / interfaces)
2) A pure planning function:

   `planLeadGeneration(goal, context): LeadGenPlan`

This function MUST:

- Take a **goal** and a **context**
- Return a **plan** as a list of ordered **steps**
- Each step has:
  - a **tool identifier** (e.g. GOOGLE_PLACES_SEARCH, HUNTER_ENRICH, EMAIL_SEQUENCE_SETUP)
  - **parameters** (what that tool will need)
  - **dependencies** (which step IDs it must wait for)
- Perform **planning only**. It must NOT execute tools or make external calls.
- We will later implement a separate **executor** that reads this plan and runs the tools.

Keep changes small, local, and TypeScript-idiomatic.

========================================
SECTION 1 — DEFINE CORE TYPES
========================================

Create a small planning module (or extend an existing one). If there is no obvious place, create:

- `src/lead/plan.ts`  (or similar path consistent with current structure)

Inside it, define the following types.

1) Tool identifiers
-------------------

Create a string union for supervisor-visible tools used in lead generation pipelines:

```ts
export type LeadToolIdentifier =
  | "GOOGLE_PLACES_SEARCH"
  | "HUNTER_DOMAIN_LOOKUP"
  | "HUNTER_ENRICH"
  | "EMAIL_SEQUENCE_SETUP"
  | "LEAD_LIST_SAVE"
  | "MONITOR_SETUP";
(If similar constants / enums already exist, reuse or align with them.)

Per-step parameters

For now, represent parameters as a generic record; we can specialise later:

ts
Copy code
export type LeadToolParams = Record<string, unknown>;
If you want to be slightly stricter, you can define:

ts
Copy code
export interface GooglePlacesSearchParams {
  query: string;
  region: string;
  country?: string;
  maxResults?: number;
}

export interface HunterDomainLookupParams {
  companyName?: string;
  website?: string;
  country?: string;
}

export interface HunterEnrichParams {
  domain: string;
  roleHint?: string; // e.g. "owner", "buyer", "head of ops"
  maxContacts?: number;
}

export interface EmailSequenceSetupParams {
  campaignName: string;
  fromIdentityId: string;
  targetSegmentId?: string;
  estimatedVolume?: number;
  startTiming?: string; // e.g. "this_week", "asap", ISO string
}

export interface MonitorSetupParams {
  listId: string;
  cadence: "daily" | "weekly" | "monthly";
  signalTypes?: string[]; // e.g. ["new_reviews", "menu_changes"]
}
and then either use LeadToolParams = GooglePlacesSearchParams | HunterDomainLookupParams | ... or keep it as Record<string, unknown> and treat these as documentation. Keep it simple and compatible with how tools are currently defined.

Plan step

Each step is a node in a DAG:

ts
Copy code
export interface LeadGenPlanStep {
  /**
   * Unique ID within the plan, e.g. "step_1", "google_places_1".
   */
  id: string;

  /**
   * High-level label for humans, optional but useful.
   */
  label?: string;

  /**
   * Which tool this step intends to call.
   */
  tool: LeadToolIdentifier;

  /**
   * Parameters to feed into that tool when the executor runs it.
   */
  params: LeadToolParams;

  /**
   * IDs of other steps that must be completed before this one can run.
   */
  dependsOn?: string[];

  /**
   * Optional notes / rationale for the planner / debugger.
   */
  note?: string;
}
Plan object

ts
Copy code
export interface LeadGenPlan {
  /**
   * Unique identifier for this plan. Can be generated by Supervisor.
   */
  id: string;

  /**
   * A short description / title, often derived from the goal.
   */
  title: string;

  /**
   * Original raw goal text (or summary) from UI / goal capture.
   */
  rawGoal: string;

  /**
   * Optional structured goal fields (see below).
   */
  goal: LeadGenGoal;

  /**
   * Context used to generate the plan (user, account, etc.).
   */
  context: LeadGenContext;

  /**
   * Ordered list of steps.
   */
  steps: LeadGenPlanStep[];

  /**
   * Optional metadata (e.g. createdAt, priority).
   */
  createdAt: string; // ISO timestamp
  priority?: "low" | "normal" | "high";
}
Goal and context types

Define light-weight goal & context structures consistent with what the UI is starting to collect (region, persona, volume, timing, etc.):

ts
Copy code
export interface LeadGenGoal {
  /**
   * Free-text from the user, as captured by the UI.
   */
  rawGoal: string;

  /**
   * Region(s) to target, e.g. "North West", "UK", "London and South East".
   */
  targetRegion?: string;

  /**
   * Persona or role, e.g. "pub landlords", "bar managers", "buyers".
   */
  targetPersona?: string;

  /**
   * Approximate number of leads or emails.
   */
  volume?: number;

  /**
   * Timing requirement, e.g. "this week", "ongoing weekly", ISO datetime, etc.
   */
  timing?: string;

  /**
   * Channels the user cares about. For now mostly email.
   */
  preferredChannels?: Array<"email" | "phone" | "linkedin">;

  /**
   * Whether the user wants ongoing monitoring as part of this goal.
   */
  includeMonitoring?: boolean;
}

/**
 * Environment & user-specific context the planner can use.
 */
export interface LeadGenContext {
  userId: string;
  accountId?: string;

  /**
   * Default country/region if goal doesn't specify.
   */
  defaultRegion?: string;
  defaultCountry?: string;

  /**
   * Default sending identity / email profile ID for outreach tools.
   */
  defaultFromIdentityId?: string;

  /**
   * Any saved preferences or flags (can be expanded later).
   */
  preferences?: Record<string, unknown>;
}
========================================
SECTION 2 — IMPLEMENT planLeadGeneration
In the same module, implement a pure function:

ts
Copy code
export function planLeadGeneration(
  goal: LeadGenGoal,
  context: LeadGenContext
): LeadGenPlan {
  // Implementation described below
}
Key constraints:

No external calls (no HTTP, no database, no tools).

Pure planning only: construct and return a LeadGenPlan object.

Use simple, deterministic logic based on goal + context.

Implementation outline:

Normalise goal & context

Inside planLeadGeneration:

Derive effective region / country:

ts
Copy code
const effectiveRegion = goal.targetRegion ?? context.defaultRegion ?? "UK";
const effectiveCountry = context.defaultCountry ?? "GB";
Derive persona / query string:

ts
Copy code
const persona = goal.targetPersona ?? "target customers";
Derive volume (fallback to e.g. 50 if missing):

ts
Copy code
const volume = goal.volume ?? 50;
Derive timing (fallback to "asap"):

ts
Copy code
const timing = goal.timing ?? "asap";
Step ID helper

Add a small helper to generate step IDs:

ts
Copy code
let stepCounter = 0;
const steps: LeadGenPlanStep[] = [];

function nextStepId(prefix: string): string {
  stepCounter += 1;
  return `${prefix}_${stepCounter}`;
}
Build GOOGLE_PLACES_SEARCH step

Goal: turn region + persona into a location-based business search.

Example:

ts
Copy code
const googlePlacesStepId = nextStepId("google_places");

steps.push({
  id: googlePlacesStepId,
  label: "Find candidate businesses via Google Places",
  tool: "GOOGLE_PLACES_SEARCH",
  params: {
    query: persona,        // e.g. "pubs", "coffee shops"
    region: effectiveRegion,
    country: effectiveCountry,
    maxResults: volume * 2 // over-fetch so we can filter later
  },
  dependsOn: [],
  note: "Initial business discovery from Google Places based on persona and region."
});
Build HUNTER_DOMAIN_LOOKUP / HUNTER_ENRICH steps

If email is a preferred channel (or unspecified), plan Hunter-based enrichment:

ts
Copy code
const hunterDomainStepId = nextStepId("hunter_domain_lookup");

steps.push({
  id: hunterDomainStepId,
  label: "Look up domains for candidate businesses",
  tool: "HUNTER_DOMAIN_LOOKUP",
  params: {
    sourceStepId: googlePlacesStepId,
    country: effectiveCountry
  },
  dependsOn: [googlePlacesStepId],
  note: "Take business names from Google Places and find domains."
});

const hunterEnrichStepId = nextStepId("hunter_enrich");

steps.push({
  id: hunterEnrichStepId,
  label: "Find target contacts at those domains",
  tool: "HUNTER_ENRICH",
  params: {
    sourceStepId: hunterDomainStepId,
    roleHint: persona,
    maxContactsPerDomain: 2
  },
  dependsOn: [hunterDomainStepId],
  note: "Use Hunter to find contacts that match the target persona."
});
Build LEAD_LIST_SAVE step

Create a step to persist the enriched leads into a central list / table:

ts
Copy code
const saveListStepId = nextStepId("lead_list_save");

steps.push({
  id: saveListStepId,
  label: "Save enriched leads to a list",
  tool: "LEAD_LIST_SAVE",
  params: {
    sourceStepId: hunterEnrichStepId,
    listName: goal.rawGoal || "Lead list",
    region: effectiveRegion,
    persona,
    estimatedVolume: volume
  },
  dependsOn: [hunterEnrichStepId],
  note: "Store all enriched leads under a named list in Wyshbone."
});
Build EMAIL_SEQUENCE_SETUP step (if email channel)

If goal.preferredChannels is undefined or includes "email", include an email sequence setup:

ts
Copy code
const wantsEmail =
  !goal.preferredChannels || goal.preferredChannels.includes("email");

if (wantsEmail && context.defaultFromIdentityId) {
  const emailSeqStepId = nextStepId("email_sequence");

  steps.push({
    id: emailSeqStepId,
    label: "Set up outbound email sequence",
    tool: "EMAIL_SEQUENCE_SETUP",
    params: {
      sourceListStepId: saveListStepId,
      campaignName: goal.rawGoal || "Outbound campaign",
      fromIdentityId: context.defaultFromIdentityId,
      estimatedVolume: volume,
      startTiming: timing
    },
    dependsOn: [saveListStepId],
    note: "Create an email sequence in the outreach system targeting the saved leads."
  });
}
Build MONITOR_SETUP step (if includeMonitoring)

If goal.includeMonitoring is true, plan a monitoring step:

ts
Copy code
if (goal.includeMonitoring) {
  const monitorStepId = nextStepId("monitor");

  steps.push({
    id: monitorStepId,
    label: "Set up ongoing monitoring for this lead list",
    tool: "MONITOR_SETUP",
    params: {
      sourceListStepId: saveListStepId,
      cadence: "weekly",
      signalTypes: ["new_reviews", "profile_changes"]
    },
    dependsOn: [saveListStepId],
    note: "Configure background monitoring to surface future signals for this list."
  });
}
Construct the final LeadGenPlan object

At the end of planLeadGeneration, return:

ts
Copy code
const planId = `lead_plan_${Date.now()}`;

const plan: LeadGenPlan = {
  id: planId,
  title: goal.rawGoal || "Lead generation plan",
  rawGoal: goal.rawGoal,
  goal,
  context,
  steps,
  createdAt: new Date().toISOString(),
  priority: "normal"
};

return plan;
========================================
SECTION 3 — USAGE EXAMPLE (for tests)
Add a small example usage in a test file or near the planner (for manual testing only):

ts
Copy code
const examplePlan = planLeadGeneration(
  {
    rawGoal: "Find 50 pubs in the North West and email the landlords this week",
    targetRegion: "North West",
    targetPersona: "pub landlords",
    volume: 50,
    timing: "this_week",
    preferredChannels: ["email"],
    includeMonitoring: true
  },
  {
    userId: "test-user-123",
    accountId: "test-account",
    defaultRegion: "UK",
    defaultCountry: "GB",
    defaultFromIdentityId: "from-identity-1"
  }
);

// examplePlan.steps should contain:
// 1) GOOGLE_PLACES_SEARCH
// 2) HUNTER_DOMAIN_LOOKUP (depends on 1)
// 3) HUNTER_ENRICH (depends on 2)
// 4) LEAD_LIST_SAVE (depends on 3)
// 5) EMAIL_SEQUENCE_SETUP (depends on 4)
// 6) MONITOR_SETUP (depends on 4)
You do NOT need to wire the executor yet. This task is complete when:

Types / interfaces are defined and exported.

planLeadGeneration exists, is pure, and returns a sensible LeadGenPlan.

A simple example plan has the expected tool sequence and dependency chain.